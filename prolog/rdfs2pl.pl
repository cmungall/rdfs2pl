/* -*- Mode: Prolog -*- */

:- module(rdfs2pl,
          [assert_schema/2,
           assert_schema/1,
           write_schema/3,
           write_schema/2]).

/** <module> compile an RDF schema to a prolog module

*/

:- use_module(library(semweb/rdf11)).
:- use_module(library(semweb/rdfs)).

:- dynamic clause_comment/2.

%! assert_schema(+Local,+Global) is det.
%
% as write_schema/2, but assert directly
assert_schema(Local,Global):-
        rdf_register_ns(Local,Global),
        assert_clauses(Local).

assert_schema(Local):-
        rdf_current_prefix(Local,_),
        assert_clauses(Local).

assert_clauses(M):-
        forall(inf_clause(M,X,[]),
               M:assert(X)).

%% write_schema(+Prefix,+Global,+Opts)
%
% writes out prolog wrapping predicates for ontology Global, using prefix Prefix
%
% E.g. write_schema(bp2,'http://www.biopax.org/release/biopax-level2.owl#')
write_schema(Local,Opts):-
        write_schema(Local,_,Opts).
write_schema(Local,Global,Opts):-
        (   var(Global)
        ->  (   rdf_current_prefix(Local,Global)
            ->  true
            ;   true)
        ;   rdf_register_ns(Local,Global)),
        write_module_schema(Local,[module(Local)|Opts]).

% prolog program consists of header and clauses
write_module_schema(M,Opts):-
        write_header(M,Opts),
        write_clauses(M,Opts).

% header consists of module declaration and exports directives
write_header(M,Opts):-
        format('%% <module> ~w~n',[M]),
        format('% Autogenerated by rdfs2pl -- see https://github.com/cmungall/rdfs2pl/~n',[]),
        nl,
        findall(E,mod_exports(M,E,Opts),Exports),
        writep( (:- module(M,Exports)) ),
        writep( (:- use_module(library(semweb/rdf11))) ),
        writep( (:- use_module(library(semweb/rdfs))) ),
        nl,
        forall((mod_exports(M,Op,Opts),Op=op(_,_,_)),
               writep( (:- Op) )),
        nl.

write_clauses(M,Opts):-
        setof(X,inf_clause(M,X,Opts),Xs),
        maplist(write_clause,Xs).

write_clause(X):-
        %X=..[_,Head|Args],
        %Head =.. [_,_,Head2],
        %format('%% ~w.~n',[Head2]),
                                %format('%~n'),
        (   clause_comment(X,Comment)
        ->  write(Comment)
        ;   true),
        writep(X),
        nl.


%%%%
% UTIL
%%%%


%% maketerm(+URI,+Args,?Term)
%
% see maketerm/6
maketerm(URI,Args,Term):-
        maketerm(URI,Args,Term,_,_,[]).
maketerm(URI,Args,Term,Opts):-
        maketerm(URI,Args,Term,_,_,Opts).

%% maketerm(+URI,+Args,?Term,?NS,?Functor,+Opts)
%
% unifies Term with a term Pred(Args) such that Pred is
% a prolog-safe variant of URI (or optionally, the
% label for URI)
%
% note: NS not used
maketerm(URI,Args,Term,_NS,_Functor,Opts):-
        member(use_labels(true),Opts),
        ont_label(URI,Label),
        member(module(M),Opts),
        !,
        psafe(Label,Pred,Opts),
        debug(schema,' pred= ~w ',[Pred]),
        T=..[Pred|Args],
        Term=..[':',M,T].
        
maketerm(URI,Args,Term,NS,Functor,Opts):-
        rdf_global_id(NS:Functor,URI),
        debug(schema,' P2P ~w ',[Functor]),
        property_to_predicate(Functor,FunctorSafe,Opts),
        T1=..[FunctorSafe|Args],
        Term=..[':',NS,T1].

make_comment(Clause, _:Term, class, Obj) :-
        numbervars(Term,8,_),
        sformat(S,'%! ~w~n%~n%  Any instance of <~w>~n%~n',[Term,Obj]),
        assert(clause_comment(Clause,S)),
        make_comment_from_def(Clause,Obj).
make_comment(Clause, _:Term, property, Obj) :-
        numbervars(Term,8,_),
        sformat(S,'%! ~w~n%~n%  Any relationship of type <~w>~n%~n',[Term,Obj]),
        assert(clause_comment(Clause,S)),
        make_comment_from_def(Clause,Obj).

make_aux_comment(Clause, _:Term, Aux) :-
        numbervars(Term,8,_),
        Term =.. [P|_],
        sformat(S,'%! ~w~n%~n%  As ~w/2 ~w~n%~n',[Term,P,Aux]),
        assert(clause_comment(Clause,S)).

make_comment_from_def(Clause,Obj) :-
        ont_desc(Obj,Desc),
        sformat(S,'%  _|~w|_~n',[Desc]),
        assert(clause_comment(Clause,S)),
        !.
make_comment_from_def(_,_).



cls(C,Opts) :-
        % call unique
        setof(C,cls1(C,Opts),Cs),
        member(C,Cs).
        
cls1(C,Opts) :-
        \+ member( exclude_classes(true), Opts),
        rdfs_individual_of(C,owl:'Class'),
        \+ rdf_is_bnode(C).

%% inf_clause(?Namespace, ?Clause, +Opts)
%
% generates a clause to be used as a directive in
% a prolog program
%
inf_clause(NS, Clause, Opts) :-
        inf_clause_meta(NS, Clause, _, Opts).
inf_clause(NS, Directive, Opts) :-
        inf_clause_meta(NS, _, Meta, Opts),
        make_meta_directive(Meta, Directive).



%% inf_clause_meta(?Namespace, ?Clause, +Opts)
%
% generates a clause to be used as a directive in
% a prolog program
%
% side effect: asserts clause_comment/2
%

% ## CLASSES
% 
% represented by unary predicates

% unary predicate: C(I)
inf_clause_meta( _NS, (Head:-Body), Meta, Opts):-
         cls(C,Opts),
         maketerm(C,[r],Meta,Opts),
         maketerm(C,[I],Head,Opts),
         (   member(expand_subclass(Opts,true),Opts)
         *-> (   Body=rdf(I,rdf:type,C),
                 make_comment( (Head:-Body), Head, class, C)
             ;   rdfs_subclass_of(D,C),
                 Body=rdf(I,rdf:type,D))
         ;   Body=rdfs_individual_of(I,C),
             make_comment( (Head:-Body), Head, class, C)).

% ## Properties
% 
% represented by binary+ predicates

% basic binary predicate: P(S,O)
inf_clause_meta( NS, (Head:-Body), Meta, Opts ):-
         property(R),
         maketerm(R,[r,r],Meta,NS,_,Opts),
         maketerm(R,[Subj,Obj],Head,NS,_F,Opts),
         make_comment( (Head:-Body), Head, property, R),
         Body=rdf_has(Subj,R,Obj).

% ternary predicate with graph: P(S,O,G)
inf_clause_meta( NS, (Head:-Body), Meta, Opts ):-
         property(R),
         maketerm(R,[r,r,g],Meta,NS,_,Opts),
         maketerm(R,[Subj,Obj,G],Head,NS,_F,Opts),
         Body=rdf(Subj,R,Obj,G),
         make_aux_comment( (Head:-Body), Head, ' where asserted in graph').

% quad predicate with graph and reified node: P(S,O,G,N)
inf_clause_meta( NS, (Head:-Body), Meta, Opts ):-
         property(R),
         member(reify(true), Opts),
         NOpts=[suffix(node)|Opts],
         maketerm(R,[r,r,g,r],Meta,NS,_,NOpts),
         maketerm(R,[Subj,Obj,G,Node],Head,NS,_F,NOpts),
         Body=(rdf(Subj,R,Obj,G),
               rdf(Node,rdf:subject,Subj),
               rdf(Node,rdf:predicate,R),
               rdf(Node,rdf:object,Obj)),
         make_aux_comment( (Head:-Body), Head, ', where asserted in graph and rdf-reified by node').
         

% ternary predicate with reified node, no graph: P_node(S,O,N)
inf_clause_meta( NS, (Head:-Body), Meta, Opts ):-
         property(R),
         member(reify(true), Opts),
         NOpts=[suffix(node)|Opts],
         maketerm(R,[r,r,r],Meta,NS,_,NOpts),
         maketerm(R,[Subj,Obj,Node],Head,NS,_F,NOpts),
         Body=(rdf(Subj,R,Obj),
               rdf(Node,rdf:subject,Subj),
               rdf(Node,rdf:predicate,R),
               rdf(Node,rdf:object,Obj)).

% generate subclass_of_P(S,O) from property P 
inf_clause_meta( NS, (Head:-Body), Meta, Opts ):-
         rdfs_individual_of(R,owl:'ObjectProperty'),
         NOpts=[prefix(subclass_of)|Opts],
         maketerm(R,[r,r],Meta,NS,_,NOpts),
         maketerm(R,[Subj,Obj],Head,NS,_F,NOpts),
         Body=(rdf(Subj,rdfs:subClassOf,Restr),
               rdf(Restr,owl:onProperty,R),
               rdf(Restr,owl:someValuesFrom,Obj)),
         make_aux_comment( (Head:-Body), Head, ', TODO').


% generate P_axiom(S,O,G,N) from property P
inf_clause_meta( NS, (Head:-Body), Meta, Opts ):-
         property(R),
         member(reify_owl(true), Opts),
         NOpts = [suffix(axiom)|Opts],
         maketerm(R,[r,r,g,r],Meta,NS,_,NOpts),
         maketerm(R,[Subj,Obj,G,Axiom],Head,NS,_F,NOpts),
         Body=(rdf(Subj,R,Obj,G),
               rdf(Axiom,owl:annotatedSource,Subj),
               rdf(Axiom,owl:annotatedProperty,R),
               rdf(Axiom,owl:annotatedTarget,Obj)),
         make_aux_comment( (Head:-Body), Head, ', where asserted in graph and owl-reified by node').


% generate P_axiom(S,O,N) from property P
inf_clause_meta( NS, (Head:-Body), Meta, Opts ):-
         property(R),
         member(reify_owl(true), Opts),
         NOpts = [suffix(axiom)|Opts],
         maketerm(R,[r,r,r],Meta,NS,_,NOpts),
         maketerm(R,[Subj,Obj,Axiom],Head,NS,_F,NOpts),
         Body=(rdf(Subj,R,Obj),
               rdf(Axiom,owl:annotatedSource,Subj),
               rdf(Axiom,owl:annotatedProperty,R),
               rdf(Axiom,owl:annotatedTarget,Obj)),
         make_aux_comment( (Head:-Body), Head, ', where owl-reified by node').

               

property_to_predicate(R,Pred,Opts):-
        property_to_predicate1(R,Pred0,Opts),
        safe_predicate(Pred0,Pred,Opts).

property_to_predicate1(R,Pred,Opts):-
        member(use_labels(true),Opts),
        !,
        debug(schema,'FETCHING ~w ',[R]),
        ont_label(R,Label),
        debug(schema,'~w ==> ~w',[R,Label]),
        downcase_atom(Label,R1),
        concat_atom(L,'-',R1),
        concat_atom(L,'_',Pred).
property_to_predicate1(R,Pred,Opts):-
        member(prolog_properties(true),Opts),
        !,
        downcase_atom(R,R1),
        concat_atom(L,'-',R1),
        concat_atom(L,'_',Pred).
property_to_predicate1(R,R,_).

safe_predicate(P1,P2,Opts):-
        T=..[P1,_,_],
        predicate_property(T,_),
        !,
        (   member(prefix(M),Opts)
        ->  concat_atom([M,P1],'_',P2)
        ;   atom_concat(P1,'_',P2)).
safe_predicate(P,P,_).

ont_label(X,Label) :- rdfs_label(X,Label),!.
ont_label(X,Label) :- rdf(X,rdfs:label,S),S=literal(type(_,Label)).

ont_desc(X,Label) :- rdf(X,'http://purl.obolibrary.org/obo/IAO_0000115',S),S=literal(type(_,Label)).



mod_exports( NS, F/N, Opts):-
        cls(C,Opts),
        maketerm(C,[-], NS:Term,Opts),
        functor(Term,F,N).

mod_exports( NS, F/N, Opts ):-
        property(R),
        maketerm(R,[-,-], NS:Term,Opts),
        functor(Term,F,N).

mod_exports( NS, F/N, Opts ):-
        property(R),
        maketerm(R,[-,-,-], NS:Term,Opts),
        functor(Term,F,N).

mod_exports( NS, F/N, Opts ):-
        property(R),
        member(reify(true), Opts),
        maketerm(R,[-,-,-], NS:Term,[suffix(node)|Opts]),
        functor(Term,F,N).
mod_exports( NS, F/N, Opts ):-
        property(R),
        member(reify(true), Opts),
        maketerm(R,[-,-,-,-], NS:Term,[suffix(node)|Opts]),
        functor(Term,F,N).

mod_exports( NS, F/N, Opts ):-
        property(R),
        member(reify_owl(true), Opts),
        maketerm(R,[-,-,-], NS:Term,[suffix(axiom)|Opts]),
        functor(Term,F,N).
mod_exports( NS, F/N, Opts ):-
        property(R),
        member(reify_owl(true), Opts),
        maketerm(R,[-,-,-,-], NS:Term,[suffix(axiom)|Opts]),
        functor(Term,F,N).

mod_exports( NS, op(300,xfy,F), Opts ):-
        property(R),
        maketerm(R,[], NS:F,Opts).

/*
inf_op( NS, F, Opts ):-
        rdfs_individual_of(C,owl:'ObjectProperty'),
        rdf_global_id(NS:F0,C),
        property_to_predicate(F0,F,Opts).

inf_op( NS, F, Opts ):-
        rdfs_individual_of(C,owl:'DatatypeProperty'),
        rdf_global_id(NS:F0,C),
        property_to_predicate(F0,F,Opts).
*/

property(R) :-
        setof(R,property1(R),Rs),member(R,Rs).  % call unique

property1(R) :- rdfs_individual_of(R,owl:'ObjectProperty').
property1(R) :- rdfs_individual_of(R,owl:'DatatypeProperty').
property1(R) :- rdfs_individual_of(R,owl:'AnnotationProperty').
property1(R) :- rdf(R,rdf:type,rdf:'Property').
        

writep(X):-
        numbervars(X,8,_,[]),
        writeq(X),
        write('.'),
        nl.



% TODO
reserved(member).

suffix_reserved(A,B) :-
        reserved(A),
        !,
        atom_concat(A,'_triple',B).
suffix_reserved(A,A).

psafe(N,Safe,Opts) :-
        select(suffix(Suffix),Opts,Opts2),
        !,
        psafe(N,X,Opts2),
        concat_atom([X,Suffix],'_',Safe).
psafe(N,Safe,Opts) :-
        select(prefix(Prefix),Opts,Opts2),
        !,
        psafe(N,X,Opts2),
        concat_atom([Prefix,X],'_',Safe).
psafe(N,Safe,_) :-
        atom_chars(N,[C|L]),
        downcase_atom(C,C2),
        lsafe([C2|L],Cs2),
        atom_chars(Safe1,Cs2),
        suffix_reserved(Safe1,Safe).

        
safe(N,Safe) :-
        atom_chars(N,Cs),
        lsafe(Cs,Cs2),
        atom_chars(Safe,Cs2).

lsafe([],[]).
lsafe([H|L],[H2|L2]) :-
        csafe(H,H2),
        lsafe(L,L2).

csafe(' ','_') :- !.
csafe('-','_') :- !.
csafe('_','_') :- !.
csafe(C,C) :-
        C @>= 'a',
        C @=< 'z',
        !.
csafe(C,C) :-
        C @>= 'A',
        C @=< 'Z',
        !.
csafe(C,C) :-
        C @>= '0',
        C @=< '9',
        !.
csafe(_,'_').


make_meta_directive(Meta, (:- rdf_meta Meta)).

