/* -*- Mode: Prolog -*- */

/** 

**/

:- module(rdfs2pl,
          [assert_schema/2,
           write_schema/3]).

:- use_module(library(semweb/rdf_db)).
:- use_module(library(semweb/rdfs)).

assert_schema(Local,Global):-
        rdf_register_ns(Local,Global),
        assert_clauses(Local).

assert_clauses(M):-
        forall(inf_clause(M,X),
               M:assert(X)).

%% write_schema(Prefix,Global,+Opts)
%
% E.g. write_schema(bp2,'http://www.biopax.org/release/biopax-level2.owl#')
write_schema(Local,Opts):-
        write_schema(Local,_,Opts).
write_schema(Local,Global,Opts):-
        (   var(Global)
        ->  rdf_current_prefix(uberon,Global)
        ;   rdf_register_ns(Local,Global)),
        write_module_schema(Local,[module(Local)|Opts]).

write_module_schema(M,Opts):-
        write_header(M,Opts),
        write_clauses(M,Opts).

write_header(M,Opts):-
        format('%% <module> ~w~n',[M]),
        format('% Autogenerated by rdfs2pl~n',[]),
        format('% Example: swipl....~n'),
        nl,
        findall(E,inf_export(M,E,Opts),Exports),
        writep( (:- module(M,Exports)) ),
        writep( (:- use_module(library(semweb/rdf_db))) ),
        writep( (:- use_module(library(semweb/rdfs))) ),
        nl,
        forall((inf_export(M,Op,Opts),Op=op(_,_,_)),
               writep( (:- Op) )),
        nl.

write_clauses(M,Opts):-
        forall(inf_clause(M,X,Opts),
               write_clause(X)).

write_clause(X):- writep(X).


%%%%
% UTIL
%%%%


%% maketerm(+URI,+Args,?Term)
maketerm(URI,Args,Term):-
        maketerm(URI,Args,Term,_,_,[]).
maketerm(URI,Args,Term,Opts):-
        maketerm(URI,Args,Term,_,_,Opts).

%% maketerm(+URI,+Args,?Term,?NS,?Functor,+Opts)
%
% unifies Term with a term Pred(Args) such that Pred is
% a prolog-safe variant of URI (or optionally, the
% label for URI)
%
% note: NS not used
maketerm(URI,Args,Term,_NS,_Functor,Opts):-
        member(use_labels(true),Opts),
        ont_label(URI,Label),
        member(module(M),Opts),
        !,
        psafe(Label,Pred),
        debug(schema,' pred= ~w ',[Pred]),
        T=..[Pred|Args],
        Term=..[':',M,T].
        
maketerm(URI,Args,Term,NS,Functor,Opts):-
        rdf_global_id(NS:Functor,URI),
        debug(schema,' P2P ~w ',[Functor]),
        property_to_predicate(Functor,FunctorSafe,Opts),
        T1=..[FunctorSafe|Args],
        Term=..[':',NS,T1].

cls(C,Opts) :-
        \+ member( exclude_classes(true), Opts),
         rdfs_individual_of(C,owl:'Class'),
         \+ rdf_is_bnode(C).


%% inf_clause(?Namespace, ?Clause, +Opts)
%
% generates a clause to be used as a directive in
% a prolog program

inf_clause( _NS, (:- rdf_meta Term), Opts):-
         cls(C,Opts),
         maketerm(C,[r],Term,Opts).
inf_clause( _NS, (Head:-Body), Opts):-
         cls(C,Opts),
         maketerm(C,[I],Head,Opts),
         Body=rdfs_individual_of(I,C).

inf_clause( NS, (:- rdf_meta Term), Opts):-
         rdfs_individual_of(R,owl:'ObjectProperty'),
         maketerm(R,[r,r],Term,NS,_,Opts).
inf_clause( NS, (Head:-Body), Opts ):-
         rdfs_individual_of(R,owl:'ObjectProperty'),
         maketerm(R,[Subj,Obj],Head,NS,_F,Opts),
         Body=rdf_has(Subj,R,Obj).

inf_clause( _NS, (:- rdf_meta Term), Opts):-
         rdfs_individual_of(R,owl:'DatatypeProperty'),
         maketerm(R,[r,-],Term,Opts).

inf_clause( NS, (Head:-Body), Opts ):-
         rdfs_individual_of(R,owl:'DatatypeProperty'),
         maketerm(R,[Subj,Obj],Head,NS,_F,Opts),
         Body = (rdf_has(Subj,R,Obj1),
                 rdf_literal_to_native(Obj1,Obj)).

property_to_predicate(R,Pred,Opts):-
        property_to_predicate1(R,Pred0,Opts),
        safe_predicate(Pred0,Pred,Opts).

property_to_predicate1(R,Pred,Opts):-
        member(use_labels(true),Opts),
        !,
        debug(schema,'FETCHING ~w ',[R]),
        ont_label(R,Label),
        debug(schema,'~w ==> ~w',[R,Label]),
        downcase_atom(Label,R1),
        concat_atom(L,'-',R1),
        concat_atom(L,'_',Pred).
property_to_predicate1(R,Pred,Opts):-
        member(prolog_properties(true),Opts),
        !,
        downcase_atom(R,R1),
        concat_atom(L,'-',R1),
        concat_atom(L,'_',Pred).
property_to_predicate1(R,R,_).

safe_predicate(P1,P2,Opts):-
        T=..[P1,_,_],
        predicate_property(T,_),
        !,
        (   member(prefix(M),Opts)
        ->  concat_atom([M,P1],'_',P2)
        ;   atom_concat(P1,'_',P2)).
safe_predicate(P,P,_).

ont_label(X,Label) :- rdfs_label(X,Label),!.
ont_label(X,Label) :- rdf(X,rdfs:label,S),S=literal(type(_,Label)).


%inf_clause(X):- inf_clauses(Xs),member(X,Xs).

inf_export( NS, F/N, Opts):-
         cls(C,Opts),
         maketerm(C,[-], NS:Term,Opts),
         functor(Term,F,N).

inf_export( NS, F/N, Opts ):-
        property(R),
        maketerm(R,[-,-], NS:Term,Opts),
        functor(Term,F,N).

inf_export( NS, op(300,xfy,F), Opts ):-
        property(R),
        maketerm(R,[], NS:F,Opts).

/*
inf_op( NS, F, Opts ):-
        rdfs_individual_of(C,owl:'ObjectProperty'),
        rdf_global_id(NS:F0,C),
        property_to_predicate(F0,F,Opts).

inf_op( NS, F, Opts ):-
        rdfs_individual_of(C,owl:'DatatypeProperty'),
        rdf_global_id(NS:F0,C),
        property_to_predicate(F0,F,Opts).
*/

property(R) :- rdfs_individual_of(R,owl:'ObjectProperty').
property(R) :- rdfs_individual_of(R,owl:'DatatypeProperty').

        

writep(X):-
        %writeq(X),
        numbervars(X,0,_,[]),
        writeq(X),
        write('.'),
        nl.


psafe(N,Safe) :-
        atom_chars(N,[C|L]),
        downcase_atom(C,C2),
        lsafe([C2|L],Cs2),
        atom_chars(Safe,Cs2).

        
safe(N,Safe) :-
        atom_chars(N,Cs),
        lsafe(Cs,Cs2),
        atom_chars(Safe,Cs2).

lsafe([],[]).
lsafe([H|L],[H2|L2]) :-
        csafe(H,H2),
        lsafe(L,L2).

csafe(' ','_') :- !.
csafe('-','_') :- !.
csafe('_','_') :- !.
csafe(C,C) :-
        C @>= 'a',
        C @=< 'z',
        !.
csafe(C,C) :-
        C @>= 'A',
        C @=< 'Z',
        !.
csafe(C,C) :-
        C @>= '0',
        C @=< '9',
        !.
csafe(_,'_').
